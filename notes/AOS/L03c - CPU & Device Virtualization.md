---
tags:
  - type/lecture
  - "#AOS"
---
Created: 2024-12-30 17:16
Source: [LINK](https://andrewrepp.com/aos_lec_L03)

# CPU and Device Virtualization

## CPU Virtualization

- The first challenge challenge here is giving the illusion to guest OS’s that they own the resources
    - similar in principle to the illusion provided by OS to apps that they are the only one running on the processor
    - Hypervisor must handle program discontinuities, fielded and passed to correct guest OS
    - Hypervisor therefore must have precise way of accounting time used on CPU by each guest OS
    - Policies for CPU Sharing:
        - proportional share
            - commensurate with the service agreement that the VM has with the hypervisor
        - fair share
            - give out equal shares to each guest OS
        - In either policy, the hypervisor must account for time used on CPU by one guest during time intended/allocated for another. This might happen due to external interrupts. Recompensing for ‘stolen time’ here.
- The second challenge is delivering events to parent guest OS
    - events are generated by process that belongs to guest OS currently executing on CPU
    - Once process has been scheduled on CPU, during execution, everything should happen at hardware speeds.
        - process will generate virtual addresses that must be translated to machine page addresses (discussed above). This is done at hardware speeds due to techniques above. Very fast.
    - process may execute a system call, or a page fault, or an exception, or there may be an unrelated external interrupt.
        - these are the discontinuities that may mess with the execution of a process
        - all such discontinuities must be passed up to parent guest Os by the hypervisor to be correctly handled.
            - events delivered as software interrupts, packaged up by the hypervisor
            - the guest OS must then field them and handle as it normally would
    - some discontinuities may require the guest OS to have privileged access to CPU (only able to handle in kernel mode)
        - this is a problem, especially in fully virtualized environment. guest OS is just user level, but doesn’t know it
        - must trap into hypervisor so it can do the work the guest OS would normally have to do
        - but some privileged instructions fail silently. noted above, see my [GIOS Notes](https://andrewrepp.com/gios_lec_P3L6.html)
            - as noted, happens in older versions of x86
        - in fully virtualized environments, communication between guest OS and hypervisor is always implicit, done via traps.
        - in paravirtualized environments, this communication can be explicit, with APIs for communication between the guest OS and hypervisor

## Device Virtualization

- here, again, we want to give the illusion to the guest that they “own” the devices
- for full virtualization, we use “trap and emulate” approach
    - not a lot of scope for innovation there. must always do what device/OS would do. Lots of finnicky details though.
- for paravirtualization, there is much more opportunity to innovate
    - the IO devices seen by guest OS are exactly those available to hypervisor
    - can innovate interaction between guest OS and hypervisor here.
    - hypervisor can create device abstractions
    - hypervisor can expose shared buffers to guest OS, so that data can be passed efficiently between guest OS and hypervisor, and to devices, without overhead of copying between address spaces
        - even delivery of data can be innovated
    - need to sort out how to transfer control between hypervisor and guest.
        - hardware manipulation must still be done by privileged operations

### Control Transfer

1. Full Virtualization
    
    - implicit (traps) from guest to hypervisor
    - when guest OS executes any privileged instruction it results in a trap. hypervisor catches and does whatever is needed
    - in the other direction (hypervisor to guest OS) is done via software interrupts (events)
2. Paravirtualization
    
    - explicit (hypercalls) from guest OS to hypervisor (example in memory section with page faults)
    - in the other direction (hypervisor to guest OS) is done via software interrupts (events), similar to full virtualization
        - difference from full virtualization is that guest OS has control via hypercalls on when event notifications are delivered
        - similar to an OS disabling interrupts

### Data Transfer

- In full virtualization environments data transfer must be done implicitly
- In paravirtualized environments (e.g. Xen) it is done explicitly, again giving opportunity to innovate
    - two aspects to resource management and accountability
        - CPU Time (time issue)
            - when an interrupt comes in, hypervisor has to de-multiplex the data coming from device to domains very quickly.
            - this takes CPU time to do, and the hypervisor must account for computation time for managing buffers on behalf of the guest OS above it
            - this is especially important in the context of e.g. a data center, where you must bill appropriate VMs for their usage
        - How the memory buffers are managed (space issue)
            - how are these allocated and managed either by guest OS or by hypervisor?
            - Xen’s async I/O rings
	            - ![[L03c_xen_async_io_ring.png]]
	            - a data structure shared between guest and Xen
                - any number of I/O rings can be allocated for handling all device I/O needs of a particular guest domain
                - the I/O ring itself is just a set of descriptors
                - idea is that requests from guest can be placed in I/O ring by populating the descriptors.
                - every request will have a unique ID
                - I/O ring is specific to a guest
                - after hypervisor completes processing a request, it will place a response back in the same I/O ring in one of the descriptors. this response will have the same ID as the original request.
                - symmetric relationship between guest and Xen in terms of request and response
                - guest is producer of requests. has a pointer into the ring that indicates where to place next request. pointer is modified by guest, but readable by Xen
                - Xen is consumer of requests. it consumes requests in the order the guest produced them. it has a pointer into the ring that indicates where it is presently servicing requests. This pointer is private to Xen.
                - Difference between guest’s request pointer and Xen’s request pointer tells Xen how many outstanding requests there are for Xen to service.
                - Xen has a second pointer for producing responses. This pointer is modified by Xen, readable by guest.
                - Guest OS has a second pointer for consuming responses. This pointer is private to the guest.
                - Difference between Xen’s response pointer and guest’s response pointer tells guest how many outstanding responses there are for guest to process.
                - Empty slots are theoretically available between request and response sections as all four pointers progress.
                - Remember, ring just has descriptors. These must have pointers to machine pages where the data actually resides.
- Network virtualization in Xen example
    - each guest has two I/O rings, one for transmission and one for reception
    - if guest wants to transmit packets, it enqueues descriptors in transmit ring, via hypercalls
        - packets that need to be transmitted are in guest OS buffers. guest embeds pointers to these buffers in descriptors in ring. data is not copied.
        - pages associated with the packets are pinned so that Xen can complete transmission of the packets
        - if more than one guest OS wants to transmit, Xen uses a round robin scheduler to transmit packets from multiple VMs
    - Receiving packets from network and passing to appropriate domain works the same, but in opposite direction.
        - hypervisor exchanges received packet for one of the guest OS pages that has been provided to Xen as the holding place for incoming packets.
        - guest OS pre-allocates network buffers for this purpose. Xen places directly there, and enqueues a descriptor. avoids copying
            - if Xen receives a packet into a machine page instead, it can just swap with a page the guest OS owns, avoiding copying that way instead.
- Disk I/O Virtualization example
    - works similarly to network virtualization example
    - Every VM has an I/O ring dedicated to disk I/O
    - communication between Xen and guest OS avoids copying, enqueues descriptors with pointers
    - philosophy is asynchronous I/O via requests/responses.
    - Requests from competing domains may be reordered
        - if this is inappropriate, Xen provides a reorder barrier for guest OS semantics, to prevent this from happening if needed.

## Usage and Billing

- all about measuring time
- The whole tenet is that we’re sharing resources between clients. Need to be able to measure them
    - CPU Usage
    - Memory Usage
    - Storage Usage
    - Network Usage
- Xen vs VMWare - and Guests
	- ![[L03c_xen_vs_vmware.png]]
	- Difference from Extensible OS is a strong focus on protection and flexibility, with sharing at full OS level